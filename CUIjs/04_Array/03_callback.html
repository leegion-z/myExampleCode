<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta charset="utf-8">
</head>
<body>
	<script type="text/javascript">
		//函数对象，赋值给变量了
		var sum = function (num1, num2) {

		}

		//函数对象，不仅仅局限于赋值给变量，还可以赋值给参数
		//也就是，将函数对象作为实参传递了。这种函数，就叫做回调函数(callback)

		//三国时期，孙权: "来，把我妹嫁给你"
		//刘备担心：
		//	1. 不去，很怂
		//	2. 去，危险
		//诸葛亮：
		// 去吧，给你三个锦囊，危险的时候打开
		// 锦囊的特点：
		//	1. 诸葛亮定义的锦囊
		//	2. 锦囊定义时，并没执行
		//	3. 将锦囊传给了赵云
		// 锦囊 ===> 就是诸葛亮定义的回调

		function goodIdea_1 () {
			alert('看第二个写的啥');
		}

		function goodIdea_2 () {
			alert('找未来丈母娘');
		}

		function goodIdea_3 () {
			alert('带着你丈母娘');
		}

		function go2EastWu (idea1, idea2, idea3) {
			//idea1是一个函数，在函数对象后面加上()，就是执行这个函数
			var msg = '站住别跑'
			if(msg === '多喝点，这个酒好喝') {
				idea1();
			}

			if(msg === '站住别跑') {
				idea2();
			}

			if(msg === '还我妹妹') {
				idea3();
			}
		}

		// go2EastWu(goodIdea_1, goodIdea_2, goodIdea_3);

		var numbers = [1,3,4,5,6,8];

		//forEach内部，无法确定遍历时要执行的操作
		//只能通过回调，告诉forEach，遍历元素时，要执行什么操作
		//回调的意义是，告诉函数，在某个时刻，应该做什么
		numbers.forEach(function (value, index) {
			console.log(value);
		})

		numbers.forEach(function (value) {
			// console.log(value * value);
			console.log(Math.pow(value, 2));
		});

		//回调函数例子：
		//

		function guoBaoPork () {
			console.log('锅包肉做好了');
		}

		function sushi () {
			console.log('寿司已准备就绪');
		}

		function waterBoilFish () {
			console.log('水已经准开了');
		}

		function betterChef (name) {
			switch (name) {
				case '水煮鱼':
					console.log('鱼在锅里，请稍等');
				break;
				case '锅包又':
					console.log('右在猪身上，正在养猪中...');
				break;
				case '生鱼片':
					console.log('刀已经被章鱼缠住');
				break;
				default:
					console.log('换个菜，不行就滚蛋');
				break;
			}
		}

		function bestChef (step) {
			step();
		}

		function guobaoyou () {
			console.log('锅包肉OK了');
		}

		function pullSilkBanana () {
			console.log('切地瓜');
			console.log('炸地瓜');
			console.log('熬糖');
			console.log('裹糖');
			console.log('出锅');
		}

		bestChef(pullSilkBanana);
		function buildHouse () {
			console.log('打地基');
			console.log('加工木头');
			console.log('组装');
			console.log('装修内饰');
		}

		bestChef(buildHouse);

		var numbers = [6, 5, 4, 3, 2, 11];
		//将数组进行从小到大的排序
		//sort方法无法确定排序(可能有成百上千个)规则，所以，需要回调函数来告诉sort方法排序的规则
		//sort方法接受一个callback，这个callback需要两个参数，第一个参数，为数组中的其中一个元素，
		//第二个参数为数组的另外一个元素,我们的回调，会被sort方法调用多次(具体多少次，有sort内的排序算法决定)
		//每次调用时，都会给callback传递两个元素，在callback内部，根据传递的元素，来告诉sort方法，谁item1在前，还是item2在前。
		//如果item1在最终排序结果中在前，则返回一个小于0的数即可
		//如果item2在最终排序结果中在前，则返回一个大于0的数即可
		//如果item1或item2在最终排序结果中，顺序不重要，则返回0

		//talk is cheap, show me the code.
		//bie BB, gei wo daima.
		// numbers.sort(function (i1, i2) {
		// 	alert('i1=' + i1 + ';i2=' + i2);
		// 	//从小到大排序
		// 	if(i1 > i2) {
		// 		return 1;
		// 	} else if (i1 < i2) {
		// 		return -1;
		// 	} else {
		// 		return 0;
		// 	}

		// });
		// alert(numbers);

		//sort函数如果没有传递参数，那边会将参数转换成字符串，再进行比较
		numbers.sort();
		alert(numbers);




	</script>
</body>
</html>